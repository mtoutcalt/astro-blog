<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Texas Hold'em Poker - Dazzle Edition Plus Pro</title>
  <style>
    /* Reset & Base Styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: linear-gradient(135deg, #0b6623, #004d00);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: transparent;
      border: 2px solid #fff;
      border-radius: 10px;
      /* Pulse animation for extra flair */
      animation: pulseBorder 3s infinite;
    }
    #controls {
      text-align: center;
      margin-top: 10px;
    }
    button, input[type="range"] {
      font-size: 16px;
      margin: 5px;
      padding: 10px 20px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    button {
      background-color: #004d00;
      color: #fff;
    }
    button:hover {
      background-color: #006600;
    }
    button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    #raiseControl {
      display: none;
      text-align: center;
      margin-top: 10px;
    }
    #raiseControl input[type="range"] {
      width: 300px;
    }
    /* Fullscreen overlay for start/restart menu */
    #menuOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      text-align: center;
      padding: 20px;
    }
    #menuOverlay h1 {
      font-size: 48px;
      margin-bottom: 20px;
    }
    /* Keyframe for pulsing border */
    @keyframes pulseBorder {
      0% { border-color: #fff; }
      50% { border-color: #ffd700; }
      100% { border-color: #fff; }
    }
  </style>
</head>
<body>
  <!-- Start/Restart Menu Overlay -->
  <div id="menuOverlay">
    <h1>Texas Hold'em Poker</h1>
    <button id="startGameButton">Start Game</button>
  </div>
  <canvas id="gameCanvas" width="1000" height="700"></canvas>
  <div id="controls">
    <button id="foldButton">Fold</button>
    <button id="callButton">Call</button>
    <button id="raiseButton">Raise</button>
    <button id="nextButton">Next</button>
    <button id="resetScore">Reset Scoreboard</button>
    <button id="musicToggle">Toggle Music</button>
  </div>
  <!-- Raise amount slider control -->
  <div id="raiseControl">
    <label for="raiseAmount">Select Raise Amount: $<span id="raiseValue">0</span></label><br>
    <input type="range" id="raiseAmount" min="0" max="100" step="5" value="0">
    <br>
    <button id="confirmRaise">Confirm Raise</button>
    <button id="cancelRaise">Cancel</button>
  </div>
  <!-- Audio Elements -->
  <audio id="cardSound" src="https://www.soundjay.com/cards/card-deal-1.mp3"></audio>
  <audio id="chipSound" src="https://www.soundjay.com/misc/cash-register-01.mp3"></audio>
  <audio id="winSound" src="https://www.soundjay.com/misc/applause-8.mp3"></audio>
  <audio id="bgMusic" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" loop></audio>
  <script>
    // ------------------------- Global Variables & Setup -------------------------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let CANVAS_WIDTH = canvas.width;
    let CANVAS_HEIGHT = canvas.height;
    const CARD_WIDTH = 70, CARD_HEIGHT = 100;
    const deckPosition = { x: CANVAS_WIDTH / 2 - CARD_WIDTH / 2, y: 40 };

    // Scoreboard for wins and losses
    let scoreboard = { wins: 0, losses: 0 };

    // Audio Elements
    const cardSound = document.getElementById("cardSound");
    const chipSound = document.getElementById("chipSound");
    const winSound = document.getElementById("winSound");
    const bgMusic = document.getElementById("bgMusic");
    let musicOn = true;

    // Dealer rotation and game flags
    let dealerIndex = 0;
    let firstHand = true;
    let gameOver = false;

    // Game state object
    let gameState = {
      phase: "preflop",
      pot: 0,
      currentBet: 10,
      communityCards: [],
      deck: [],
      message: "Dealing new hand...",
      waitingForPlayer: false,
      dealing: false,
      chipAnim: null,
      particles: []
    };

    let playerChips = 100; // starting chips

    // Standard deck definitions
    const suits = ["♠", "♥", "♦", "♣"];
    const ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    const rankValues = {
      "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7,
      "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13, "A": 14
    };

    function createDeck() {
      let deck = [];
      suits.forEach(suit => {
        ranks.forEach(rank => {
          deck.push({ rank, suit, value: rankValues[rank] });
        });
      });
      return deck;
    }

    // Fisher–Yates shuffle
    function shuffle(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }

    // ------------------------- Player Class & Setup -------------------------
    class Player {
      constructor(name, isHuman) {
        this.name = name;
        this.isHuman = isHuman;
        this.hand = [];
        this.active = true;
        this.bet = 0;
        this.action = "";
        this.bestHand = null;
      }
    }

    let players = [
      new Player("You", true),
      new Player("CPU 1", false),
      new Player("CPU 2", false),
      new Player("CPU 3", false)
    ];

    // ------------------------- Particle System (Confetti) -------------------------
    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4 - 2;
        this.alpha = 1;
        this.size = Math.random() * 3 + 2;
        this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= 0.02;
      }
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function spawnParticles(x, y, count) {
      for (let i = 0; i < count; i++) {
        gameState.particles.push(new Particle(x, y));
      }
    }

    // ------------------------- Responsive Canvas -------------------------
    function resizeCanvas() {
      const ratio = 1000 / 700;
      let newWidth = window.innerWidth * 0.9;
      let newHeight = newWidth / ratio;
      if (newHeight > window.innerHeight * 0.8) {
        newHeight = window.innerHeight * 0.8;
        newWidth = newHeight * ratio;
      }
      canvas.width = newWidth;
      canvas.height = newHeight;
      CANVAS_WIDTH = newWidth;
      CANVAS_HEIGHT = newHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ------------------------- Main Game Loop -------------------------
    let backgroundTime = 0;
    function gameLoop() {
      backgroundTime += 0.005;
      // Update particles and remove faded ones
      gameState.particles = gameState.particles.filter(p => p.alpha > 0);
      gameState.particles.forEach(p => p.update());
      drawTable();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    // ------------------------- Drawing Functions -------------------------
    function drawTable() {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      // Animated radial gradient background
      let grad = ctx.createRadialGradient(
        CANVAS_WIDTH / 2,
        CANVAS_HEIGHT / 2,
        100,
        CANVAS_WIDTH / 2,
        CANVAS_HEIGHT / 2,
        Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2.2
      );
      let r1 = Math.floor(50 + 50 * Math.sin(backgroundTime));
      let color1 = `rgb(${r1},100,50)`;
      let r2 = Math.floor(20 + 20 * Math.cos(backgroundTime));
      let color2 = `rgb(${r2},50,20)`;
      grad.addColorStop(0, color1);
      grad.addColorStop(1, color2);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Table ellipse
      ctx.fillStyle = "#006600";
      ctx.beginPath();
      ctx.ellipse(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CANVAS_WIDTH/2.8, CANVAS_HEIGHT/2.5, 0, 0, 2 * Math.PI);
      ctx.fill();

      // Draw deck if cards remain
      if (gameState.deck.length > 0) {
        drawCardBack(deckPosition.x, deckPosition.y);
      }

      // Draw community cards
      let communityCount = gameState.communityCards.length;
      let startX = CANVAS_WIDTH / 2 - ((CARD_WIDTH + 15) * communityCount) / 2;
      let comY = CANVAS_HEIGHT / 2 - CARD_HEIGHT / 2;
      gameState.communityCards.forEach((card, index) => {
        drawCard(startX + index * (CARD_WIDTH + 15), comY, card);
      });

      // Draw player cards
      let playerX = CANVAS_WIDTH / 2 - CARD_WIDTH - 10;
      let playerY = CANVAS_HEIGHT - CARD_HEIGHT - 40;
      players[0].hand.forEach((card, index) => {
        drawCard(playerX + index * (CARD_WIDTH + 15), playerY, card);
      });

      // Draw CPU players
      const cpuPositions = [
        { x: 50, y: 50 },
        { x: CANVAS_WIDTH - CARD_WIDTH * 2 - 50, y: 50 },
        { x: 50, y: CANVAS_HEIGHT - CARD_HEIGHT - 150 }
      ];
      for (let i = 1; i < players.length; i++) {
        let pos = cpuPositions[i - 1];
        if (gameState.phase === "showdown" || !players[i].active) {
          players[i].hand.forEach((card, idx) => {
            drawCard(pos.x + idx * (CARD_WIDTH + 15), pos.y, card);
          });
          if (gameState.phase === "showdown" && players[i].active && players[i].bestHand) {
            ctx.fillStyle = "#fff";
            ctx.font = "16px Arial";
            ctx.fillText(getHandName(players[i].bestHand), pos.x, pos.y + CARD_HEIGHT + 20);
          }
        } else {
          drawCardBack(pos.x, pos.y);
          drawCardBack(pos.x + CARD_WIDTH + 15, pos.y);
        }
        ctx.fillStyle = "#fff";
        ctx.font = "18px Arial";
        ctx.fillText(players[i].name, pos.x, pos.y - 15);
        ctx.fillText(players[i].active ? (players[i].action || "In") : "Folded", pos.x, pos.y - 35);
      }

      // Draw scoreboard
      ctx.fillStyle = "#fff";
      ctx.font = "20px Arial";
      ctx.fillText("Wins: " + scoreboard.wins, CANVAS_WIDTH - 150, CANVAS_HEIGHT - 50);
      ctx.fillText("Losses: " + scoreboard.losses, CANVAS_WIDTH - 150, CANVAS_HEIGHT - 20);

      // Display pot
      ctx.font = "bold 22px Arial";
      const potText = "Pot: $" + gameState.pot;
      const potTextWidth = ctx.measureText(potText).width;
      const potX = CANVAS_WIDTH / 2 - potTextWidth / 2;
      const potY = CANVAS_HEIGHT / 2 - 280;
      ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
      ctx.fillRect(potX - 10, potY - 22, potTextWidth + 20, 30);
      ctx.fillStyle = "#fff";
      ctx.fillText(potText, potX, potY);

      // Display player's chip count
      ctx.fillStyle = "#fff";
      ctx.font = "22px Arial";
      ctx.fillText("Your Chips: $" + playerChips, 20, CANVAS_HEIGHT - 20);
      drawChip(150, CANVAS_HEIGHT - 50, playerChips);

      // Message box
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(20, CANVAS_HEIGHT - 100, CANVAS_WIDTH - 40, 40);
      ctx.fillStyle = "#fff";
      ctx.font = "20px Arial";
      ctx.fillText(gameState.message, 30, CANVAS_HEIGHT - 70);

      // Chip win animation if active
      if (gameState.chipAnim) {
        drawChip(gameState.chipAnim.x, gameState.chipAnim.y, gameState.pot);
      }
      
      // Draw confetti particles
      gameState.particles.forEach(p => p.draw(ctx));
    }

    function drawCard(x, y, card) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 5;
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.fillStyle = (card.suit === "♥" || card.suit === "♦") ? "#d00" : "#000";
      ctx.font = "22px Arial";
      ctx.fillText(card.rank + card.suit, x + 8, y + 30);
      ctx.restore();
    }

    function drawCardBack(x, y) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      ctx.shadowBlur = 5;
      ctx.fillStyle = "#333";
      ctx.fillRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, CARD_WIDTH, CARD_HEIGHT);
      ctx.fillStyle = "#fff";
      ctx.font = "18px Arial";
      ctx.fillText("Poker", x + 10, y + 30);
      ctx.restore();
    }

    function drawChip(x, y, amount) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.fillStyle = "#c00";
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = "#fff";
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.fillText("$" + amount, x, y + 5);
      ctx.restore();
    }

    // ------------------------- Update Buttons (with All-In logic) -------------------------
    function updateButtons() {
      if (playerChips === 0) {
        document.getElementById("foldButton").disabled = true;
        document.getElementById("callButton").disabled = true;
        document.getElementById("raiseButton").disabled = true;
        document.getElementById("nextButton").disabled = gameState.dealing;
      } else {
        document.getElementById("foldButton").disabled = !gameState.waitingForPlayer;
        document.getElementById("callButton").disabled = !gameState.waitingForPlayer;
        document.getElementById("raiseButton").disabled = !gameState.waitingForPlayer;
        document.getElementById("nextButton").disabled = gameState.waitingForPlayer || gameState.dealing;
      }
    }

    // ------------------------- End Game & Menu Overlay -------------------------
    function checkGameOver() {
      if (playerChips <= 0) {
        gameState.message = "Game Over! You lost all your chips.";
        gameOver = true;
        disableAllButtons();
        scoreboard.losses++;
        drawTable();
        showMenu("Game Over! Try Again?");
      } else if (playerChips >= 1000) {
        gameState.message = "Congratulations! You reached $1000!";
        gameOver = true;
        disableAllButtons();
        scoreboard.wins++;
        spawnParticles(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 150);
        drawTable();
        showMenu("You Win! Play Again?");
      }
    }

    function disableAllButtons() {
      document.getElementById("foldButton").disabled = true;
      document.getElementById("callButton").disabled = true;
      document.getElementById("raiseButton").disabled = true;
      document.getElementById("nextButton").disabled = true;
    }

    function showMenu(message) {
      const overlay = document.getElementById("menuOverlay");
      overlay.innerHTML = "<h1>" + message + "</h1><button id='restartGameButton'>Restart Game</button>";
      overlay.style.display = "flex";
      document.getElementById("restartGameButton").addEventListener("click", () => {
        overlay.style.display = "none";
        gameOver = false;
        playerChips = 100;
        startHand();
      });
    }

    // ------------------------- Game Initialization & Hand Setup -------------------------
    function startHand() {
      if (!firstHand) {
        dealerIndex = (dealerIndex + 1) % players.length;
      } else {
        firstHand = false;
      }
      const smallBlindAmount = 5;
      const bigBlindAmount = 10;
      const smallBlindIndex = (dealerIndex + 1) % players.length;
      const bigBlindIndex = (dealerIndex + 2) % players.length;
      gameState.phase = "preflop";
      gameState.pot = 0;
      gameState.currentBet = bigBlindAmount;
      gameState.communityCards = [];
      gameState.deck = createDeck();
      shuffle(gameState.deck);

      players.forEach(p => {
        p.hand = [];
        p.active = true;
        p.bet = 0;
        p.action = "";
        p.bestHand = null;
      });

      // Post blinds
      if (smallBlindIndex !== 0) {
        players[smallBlindIndex].bet = smallBlindAmount;
      } else {
        playerChips = Math.max(0, playerChips - smallBlindAmount);
        players[0].bet = smallBlindAmount;
      }
      if (bigBlindIndex !== 0) {
        players[bigBlindIndex].bet = bigBlindAmount;
      } else {
        playerChips = Math.max(0, playerChips - bigBlindAmount);
        players[0].bet = bigBlindAmount;
      }
      gameState.pot = smallBlindAmount + bigBlindAmount;
      gameState.message = `Blinds posted: ${players[smallBlindIndex].name} (SB $${smallBlindAmount}), ${players[bigBlindIndex].name} (BB $${bigBlindAmount}). Dealing new hand...`;

      gameState.waitingForPlayer = false;
      animateDeal();
    }

    // ------------------------- Card Dealing Animation with Flip Effect -------------------------
    function animateDeal() {
      gameState.dealing = true;
      let dealOrder = [];
      for (let i = 0; i < 2; i++) {
        players.forEach(p => { dealOrder.push(p); });
      }
      let dealIndex = 0;
      function dealNext() {
        if (dealIndex < dealOrder.length) {
          let p = dealOrder[dealIndex];
          setTimeout(() => {
            p.hand.push(gameState.deck.pop());
            cardSound.currentTime = 0;
            cardSound.play();
            dealIndex++;
            dealNext();
          }, 150);
        } else {
          gameState.dealing = false;
          gameState.waitingForPlayer = true;
          gameState.message = "New hand! Place your bet: Call, Raise or Fold.";
          updateButtons();
        }
      }
      dealNext();
    }

    function nextPhase() {
      if (gameState.dealing) return;
      if (gameState.phase === "preflop") {
        gameState.communityCards.push(gameState.deck.pop());
        gameState.communityCards.push(gameState.deck.pop());
        gameState.communityCards.push(gameState.deck.pop());
        gameState.phase = "flop";
        gameState.message = "Flop dealt. Place your bet.";
      } else if (gameState.phase === "flop") {
        gameState.communityCards.push(gameState.deck.pop());
        gameState.phase = "turn";
        gameState.message = "Turn dealt. Place your bet.";
      } else if (gameState.phase === "turn") {
        gameState.communityCards.push(gameState.deck.pop());
        gameState.phase = "river";
        gameState.message = "River dealt. Place your bet.";
      } else if (gameState.phase === "river") {
        gameState.phase = "showdown";
        gameState.message = "Showdown! Evaluating hands...";
        setTimeout(showdown, 800);
        return;
      }
      gameState.currentBet = 10;
      gameState.waitingForPlayer = true;
      updateButtons();
    }

    // ------------------------- Player Actions -------------------------
    // Modified playerCall to handle all‑in if you lack enough chips.
    function playerCall() {
      if (!gameState.waitingForPlayer || gameState.dealing) return;
      if (playerChips < gameState.currentBet) {
        // Not enough chips to fully call – go all in
        let allInAmount = playerChips;
        players[0].bet += allInAmount;
        gameState.pot += allInAmount;
        playerChips = 0;
        players[0].action = "All In (Call)";
        gameState.message = "You are all in with $" + players[0].bet + ". CPU players are deciding...";
        gameState.waitingForPlayer = false;
        updateButtons();
        setTimeout(simulateCPUActions, 800);
        return;
      }
      // Otherwise, full call:
      playerChips -= gameState.currentBet;
      players[0].bet += gameState.currentBet;
      players[0].action = "Called";
      gameState.pot += gameState.currentBet;
      gameState.message = "You called. CPU players are deciding...";
      gameState.waitingForPlayer = false;
      updateButtons();
      setTimeout(simulateCPUActions, 800);
    }

    function showRaiseControl() {
      const raiseSlider = document.getElementById("raiseAmount");
      const minRaise = gameState.currentBet + 10;
      raiseSlider.min = minRaise;
      raiseSlider.max = playerChips;
      raiseSlider.value = minRaise;
      document.getElementById("raiseValue").textContent = minRaise;
      document.getElementById("raiseControl").style.display = "block";
      gameState.waitingForPlayer = false;
      updateButtons();
    }

    // Modified playerRaise to mark an all‑in raise if you use your last chips.
    function playerRaise(selectedAmount) {
      if (playerChips < selectedAmount) {
        gameState.message = "Not enough chips to raise!";
        return;
      }
      playerChips -= selectedAmount;
      players[0].bet += selectedAmount;
      if (playerChips === 0) {
        players[0].action = "All In (Raise)";
      } else {
        players[0].action = "Raised";
      }
      gameState.pot += selectedAmount;
      gameState.currentBet = selectedAmount;
      gameState.message = "You raised to $" + gameState.currentBet + ". CPU players are deciding...";
      document.getElementById("raiseControl").style.display = "none";
      updateButtons();
      setTimeout(simulateCPUActions, 800);
    }

    function playerFold() {
      if (!gameState.waitingForPlayer || gameState.dealing) return;
      players[0].active = false;
      players[0].action = "Folded";
      gameState.message = "You folded. Hand over.";
      gameState.waitingForPlayer = false;
      updateButtons();
      setTimeout(endHandAfterFold, 1500);
    }

    function endHandAfterFold() {
      checkGameOver();
      if (!gameOver) startHand();
    }

    function simulateCPUActions() {
      let phaseThreshold;
      switch (gameState.phase) {
        case "preflop": phaseThreshold = 0.8; break;
        case "flop": phaseThreshold = 0.7; break;
        case "turn": phaseThreshold = 0.6; break;
        case "river": phaseThreshold = 0.5; break;
        default: phaseThreshold = 0.7;
      }
      players.forEach((p, index) => {
        if (!p.isHuman && p.active) {
          setTimeout(() => {
            let decision = Math.random();
            if (decision < phaseThreshold) {
              p.bet += gameState.currentBet;
              p.action = "Called";
              gameState.pot += gameState.currentBet;
            } else if (decision < phaseThreshold + 0.2) {
              p.bet += gameState.currentBet + 10;
              p.action = "Raised";
              gameState.pot += gameState.currentBet + 10;
              gameState.currentBet += 10;
            } else {
              p.active = false;
              p.action = "Folded";
            }
          }, 500);
        }
      });
      gameState.message += " Betting round complete. Click Next to continue.";
      updateButtons();
    }

    // ------------------------- Hand Evaluation Functions -------------------------
    function evaluateHand(cards) {
      let sorted = cards.slice().sort((a, b) => b.value - a.value);
      let rankCount = {};
      let suitCount = {};
      sorted.forEach(card => {
        rankCount[card.value] = (rankCount[card.value] || 0) + 1;
        suitCount[card.suit] = (suitCount[card.suit] || 0) + 1;
      });
      let flushSuit = null;
      for (let suit in suitCount) {
        if (suitCount[suit] >= 5) { flushSuit = suit; break; }
      }
      let flushCards = flushSuit ? sorted.filter(card => card.suit === flushSuit) : [];
      let uniqueValues = [...new Set(sorted.map(card => card.value))].sort((a, b) => b - a);
      let straightHigh = null;
      for (let i = 0; i <= uniqueValues.length - 5; i++) {
        let seq = true;
        for (let j = 0; j < 4; j++) {
          if (uniqueValues[i+j] - 1 !== uniqueValues[i+j+1]) { seq = false; break; }
        }
        if (seq) { straightHigh = uniqueValues[i]; break; }
      }
      if (!straightHigh && uniqueValues.includes(14) && uniqueValues.includes(5) &&
          uniqueValues.includes(4) && uniqueValues.includes(3) && uniqueValues.includes(2)) {
        straightHigh = 5;
      }
      let straightFlushHigh = null;
      if (flushCards.length >= 5) {
        let uniqueFlush = [...new Set(flushCards.map(card => card.value))].sort((a, b) => b - a);
        for (let i = 0; i <= uniqueFlush.length - 5; i++) {
          let seq = true;
          for (let j = 0; j < 4; j++) {
            if (uniqueFlush[i+j] - 1 !== uniqueFlush[i+j+1]) { seq = false; break; }
          }
          if (seq) { straightFlushHigh = uniqueFlush[i]; break; }
        }
        if (!straightFlushHigh && uniqueFlush.includes(14) && uniqueFlush.includes(5) &&
            uniqueFlush.includes(4) && uniqueFlush.includes(3) && uniqueFlush.includes(2)) {
          straightFlushHigh = 5;
        }
      }
      if (straightFlushHigh) return { rank: 8, highCard: straightFlushHigh, kickers: [] };
      let four = Object.keys(rankCount).find(val => rankCount[val] == 4);
      if (four) {
        four = parseInt(four);
        let kicker = sorted.find(card => card.value !== four).value;
        return { rank: 7, highCard: four, kickers: [kicker] };
      }
      let threes = Object.keys(rankCount).filter(val => rankCount[val] >= 3).map(Number).sort((a, b) => b - a);
      if (threes.length > 0) {
        let pair = Object.keys(rankCount).filter(val => rankCount[val] >= 2 && parseInt(val) !== threes[0]).map(Number).sort((a, b) => b - a);
        if (pair.length > 0) return { rank: 6, highCard: threes[0], kickers: [pair[0]] };
      }
      if (flushCards.length >= 5) {
        return { rank: 5, highCard: flushCards[0].value, kickers: flushCards.slice(1, 5).map(card => card.value) };
      }
      if (straightHigh) return { rank: 4, highCard: straightHigh, kickers: [] };
      if (threes.length > 0) {
        let kickers = sorted.filter(card => card.value !== threes[0]).slice(0, 2).map(card => card.value);
        return { rank: 3, highCard: threes[0], kickers: kickers };
      }
      let pairs = Object.keys(rankCount).filter(val => rankCount[val] == 2).map(Number).sort((a, b) => b - a);
      if (pairs.length >= 2) {
        let kicker = sorted.find(card => card.value !== pairs[0] && card.value !== pairs[1]).value;
        return { rank: 2, highCard: pairs[0], kickers: [pairs[1], kicker] };
      }
      if (pairs.length >= 1) {
        let kickers = sorted.filter(card => card.value !== pairs[0]).slice(0, 3).map(card => card.value);
        return { rank: 1, highCard: pairs[0], kickers: kickers };
      }
      return { rank: 0, highCard: sorted[0].value, kickers: sorted.slice(1, 5).map(card => card.value) };
    }

    function getHandName(handValue) {
      switch (handValue.rank) {
        case 8: return "Straight Flush";
        case 7: return "Four of a Kind";
        case 6: return "Full House";
        case 5: return "Flush";
        case 4: return "Straight";
        case 3: return "Three of a Kind";
        case 2: return "Two Pair";
        case 1: return "One Pair";
        default: return "High Card";
      }
    }

    function compareHands(handA, handB) {
      if (handA.rank !== handB.rank) return handA.rank - handB.rank;
      if (handA.highCard !== handB.highCard) return handA.highCard - handB.highCard;
      for (let i = 0; i < Math.min(handA.kickers.length, handB.kickers.length); i++) {
        if (handA.kickers[i] !== handB.kickers[i]) return handA.kickers[i] - handB.kickers[i];
      }
      return 0;
    }

    function animateChipWin(winner, callback) {
      const duration = 1000;
      const startTime = performance.now();
      const startPos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 - 280 };
      const chipPositions = [
        { x: 150, y: CANVAS_HEIGHT - 50 },
        { x: CANVAS_WIDTH - 150, y: 50 },
        { x: 150, y: 50 },
        { x: 50, y: CANVAS_HEIGHT - 100 }
      ];
      let winnerIndex = players.indexOf(winner);
      const endPos = chipPositions[winnerIndex];
      function animate(now) {
        let progress = Math.min((now - startTime) / duration, 1);
        let bounce = 1 - Math.pow(1 - progress, 3);
        gameState.chipAnim = {
          x: startPos.x + (endPos.x - startPos.x) * bounce,
          y: startPos.y + (endPos.y - startPos.y) * bounce
        };
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          gameState.chipAnim = null;
          callback();
        }
      }
      chipSound.currentTime = 0;
      chipSound.play();
      requestAnimationFrame(animate);
    }

    function showdown() {
      if (!players[0].active) {
        gameState.message = "You folded. You lose this hand.";
        setTimeout(() => {
          checkGameOver();
          if (!gameOver) startHand();
        }, 2000);
        return;
      }
      let results = [];
      players.forEach(p => {
        if (p.active) {
          let allCards = p.hand.concat(gameState.communityCards);
          let handValue = evaluateHand(allCards);
          p.bestHand = handValue;
          results.push({ player: p, handValue: handValue });
        }
      });
      results.sort((a, b) => compareHands(b.handValue, a.handValue));
      let winner = results[0].player;
      let handName = getHandName(winner.bestHand);
      gameState.message = "Showdown! " + winner.name + " wins with " + handName + " and takes $" + gameState.pot + ".";
      if (winner.isHuman) {
        playerChips += gameState.pot;
        winSound.currentTime = 0;
        winSound.play();
        spawnParticles(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 150);
      }
      animateChipWin(winner, () => {
        setTimeout(() => {
          checkGameOver();
          if (!gameOver) startHand();
        }, 1500);
      });
    }

    // ------------------------- Button Event Listeners -------------------------
    document.getElementById("foldButton").addEventListener("click", playerFold);
    document.getElementById("callButton").addEventListener("click", playerCall);
    document.getElementById("raiseButton").addEventListener("click", showRaiseControl);
    document.getElementById("nextButton").addEventListener("click", nextPhase);
    document.getElementById("musicToggle").addEventListener("click", () => {
      if (musicOn) { bgMusic.pause(); musicOn = false; }
      else { bgMusic.play(); musicOn = true; }
    });
    document.getElementById("resetScore").addEventListener("click", () => {
      scoreboard = { wins: 0, losses: 0 };
    });
    document.getElementById("startGameButton").addEventListener("click", () => {
      document.getElementById("menuOverlay").style.display = "none";
      bgMusic.play();
      startHand();
    });
    const raiseSlider = document.getElementById("raiseAmount");
    raiseSlider.addEventListener("input", () => {
      document.getElementById("raiseValue").textContent = raiseSlider.value;
    });
    document.getElementById("confirmRaise").addEventListener("click", () => {
      playerRaise(parseInt(raiseSlider.value));
    });
    document.getElementById("cancelRaise").addEventListener("click", () => {
      document.getElementById("raiseControl").style.display = "none";
      gameState.waitingForPlayer = true;
      updateButtons();
    });
  </script>
</body>
</html>
